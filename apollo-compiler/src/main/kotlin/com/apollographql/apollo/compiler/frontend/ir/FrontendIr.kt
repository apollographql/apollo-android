package com.apollographql.apollo.compiler.frontend.ir

import com.apollographql.apollo.compiler.frontend.GQLFragmentDefinition
import com.apollographql.apollo.compiler.frontend.GQLOperationDefinition
import com.apollographql.apollo.compiler.frontend.GQLTypeDefinition
import com.apollographql.apollo.compiler.frontend.GQLValue

/**
 * FrontendIr is computed from the GQLDocuments. It resolves field definitions, operation names, etc.. so it's easier to work with and
 * we don't have to add assertions. Additionally:
 * - it merges fields with the same responseName in a selectionSet (but doesn't merge in sub  selection sets)
 * - it can represent arbitrary @include directives combinations generated by merging the above fields
 */
internal data class FrontendIr(
    val operations: List<Operation>,
    val fragmentDefinitions: List<NamedFragmentDefinition>,
    val allFragmentDefinitions: Map<String, NamedFragmentDefinition>
) {
  data class Operation(
      val name: String,
      val operationType: FrontendIrBuilder.OperationType,
      val typeDefinition: GQLTypeDefinition,
      val variables: List<Variable>,
      val description: String?,
      val selections: List<Selection>,
      val sourceWithFragments: String,
      val gqlOperationDefinition: GQLOperationDefinition
  )

  data class NamedFragmentDefinition(
      val name: String,
      val description: String?,
      val selections: List<Selection>,
      val typeCondition: GQLTypeDefinition,
      val source: String,
      val gqlFragmentDefinition: GQLFragmentDefinition
  )

  data class InlineFragmentDefinition(
      val selections: List<Selection>,
      val typeCondition: GQLTypeDefinition
  )

  data class Variable(val name: String, val defaultValue: GQLValue?, val type: Type)

  data class Argument(
      val name: String,
      val defaultValue: GQLValue?,
      val value: GQLValue,
      val type: Type)

  sealed class Selection {
    data class Field(val alias: String?,
                     val name: String,
                     val condition: Condition,
                     val type: Type,
                     val arguments: List<Argument>,
                     val description: String?,
                     val deprecationReason: String?,
                     val selections: List<Selection>
    ) : Selection() {
      val responseName = alias ?: name
    }

    data class InlineFragment(val fragmentDefinition: InlineFragmentDefinition, val condition: Condition) : Selection()

    data class FragmentSpread(val name: String, val condition: Condition) : Selection()
  }

  sealed class Condition {
    abstract fun toBoolean(variables: Map<String, Boolean>): Boolean
    abstract fun simplify(): Condition

    object True : Condition() {
      override fun toBoolean(variables: Map<String, Boolean>) = true
      override fun simplify() = this
    }

    object False : Condition() {
      override fun toBoolean(variables: Map<String, Boolean>) = false
      override fun simplify() = this
    }

    data class Or(val conditions: Set<Condition>) : Condition() {
      init {
        check(conditions.isNotEmpty()) {
          "ApolloGraphQL: cannot create a 'Or' condition from an empty list"
        }
      }

      override fun toBoolean(variables: Map<String, Boolean>) = conditions.firstOrNull { it.toBoolean(variables) } != null
      override fun simplify() = conditions.filter {
        it != False
      }.map { it.simplify() }
          .let {
        when {
          it.contains(True) -> True
          it.isEmpty() -> False
          it.size == 1 -> it.first()
          else -> {
            Or(it.toSet())
          }
        }
      }
    }

    data class And(val conditions: Set<Condition>) : Condition() {
      init {
        check(conditions.isNotEmpty()) {
          "ApolloGraphQL: cannot create a 'And' condition from an empty list"
        }
      }

      override fun toBoolean(variables: Map<String, Boolean>) = conditions.firstOrNull { !it.toBoolean(variables) } == null
      override fun simplify() = conditions.filter {
        it != True
      }.map { it.simplify() }
          .let {
        when {
          it.contains(False) -> False
          it.isEmpty() -> True
          it.size == 1 -> it.first()
          else -> {
            And(it.toSet())
          }
        }
      }
    }


    data class Variable(
        val name: String,
        val inverted: Boolean,
    ) : Condition() {
      override fun toBoolean(variables: Map<String, Boolean>) = variables.get(name)?.let {
        if (inverted) {
          it.not()
        } else {
          it
        }
      } ?: throw IllegalStateException("ApolloGraphQL: Unknown variable: $name in ${variables.keys}")

      override fun simplify() = this
    }
  }

  sealed class Type {
    abstract val leafTypeDefinition: GQLTypeDefinition

    class NonNull(val ofType: Type) : Type() {
      override val leafTypeDefinition = ofType.leafTypeDefinition
    }

    class List(val ofType: Type) : Type() {
      override val leafTypeDefinition = ofType.leafTypeDefinition
    }

    class Named(val typeDefinition: GQLTypeDefinition) : Type() {
      override val leafTypeDefinition = typeDefinition
    }
  }
}