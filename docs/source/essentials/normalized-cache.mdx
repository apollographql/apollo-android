---
title: Caching response data
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';

Apollo Android has 2 different kinds of caches: HTTP cache and normalized cache. The HTTP cache is easier to setup but also has more limitations. This page focuses on the normalized cache. If you're looking for a simpler albeit coarser caching, take a look at the [HTTP cache](http-cache).

## Data Normalization:

The `normalized cache` stores objects by ID.

```graphl
query BookWithAuthorName {
  favoriteBook {
    id
    isbn
    title
    author {
      id
      name
    }
  }
}

query AuthorById($id: String!) {
  author(id: $id) {
      id
      name
    }
  }
}
```

In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This is because the author is stored only once in the cache.

## Storing your data in memory

Apollo Android comes with a `LruNormalizedCache` that will store your

## Persisting your data in SQLite

## Specifying your object IDs

## Reacting to changes in the cache


To enable Normalized Disk Cache support, add the dependency to your project's build.gradle file. The latest version is
[![Download](https://api.bintray.com/packages/apollographql/android/apollo/images/download.svg)](https://bintray.com/apollographql/android/apollo-normalized-cache-sqlite/_latestVersion)

```kotlin:title=build.gradle
dependencies {
  implementation("com.apollographql.apollo:apollo-normalized-cache-sqlite:x.y.z")
}
```

**Note:** As of version 2.1.0, Cache module is published via Kotlin Multiplatform and that requires variant matching in Android projects.
 Only if you define a custom `buildType` please also put `matchingFallbacks`.

<MultiCodeBlock>

```kotlin:title=build.gradle
android {
  buildTypes {
    create("custom") {
      // your code...
      matchingFallbacks = listOf("debug")
    }
  }
}
```

```groovy:title=build.gradle
android {
  buildTypes {
    custom {
      // your code...
      matchingFallbacks = ["debug"]
    }
  }
}
```

</MultiCodeBlock>

### Usage

<MultiCodeBlock>

```kotlin:title=Kotlin             
// Create NormalizedCacheFactory
// Please note that if null is passed in as the name, you will get an in-memory SQLite database that 
// will not persist across restarts of the app.
val cacheFactory = SqlNormalizedCacheFactory(this, "github_cache")
val resolver: CacheKeyResolver = object : CacheKeyResolver() {
  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {
    return formatCacheKey(recordSet["id"] as String?)
  }

  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {
    return formatCacheKey(field.resolveArgument("id", variables) as String?)
  }

  private fun formatCacheKey(id: String?) = when {
    id.isNullOrEmpty() -> CacheKey.NO_KEY
    else -> CacheKey.from(id)
  }
}

val apolloClient = ApolloClient.builder()
    .serverUrl("/")
    .normalizedCache(cacheFactory, resolver)
    .okHttpClient(okHttpClient)
    .build()
```

```java:title=Java
// Create NormalizedCacheFactory
// Please note that if null is passed in as the name, you will get an in-memory SQLite database that 
// will not persist across restarts of the app.
NormalizedCacheFactory cacheFactory = new SqlNormalizedCacheFactory(context, "db_name");

// Create the cache key resolver, this example works well when all types have globally unique ids.
CacheKeyResolver resolver =  new CacheKeyResolver() {
   @NotNull @Override
   public CacheKey fromFieldRecordSet(@NotNull ResponseField field, @NotNull Map<String, Object> recordSet) {
     return formatCacheKey((String) recordSet.get("id"));
   }
 
   @NotNull @Override
   public CacheKey fromFieldArguments(@NotNull ResponseField field, @NotNull Operation.Variables variables) {
     return formatCacheKey((String) field.resolveArgument("id", variables));
   }
 
   private CacheKey formatCacheKey(String id) {
     if (id == null || id.isEmpty()) {
       return CacheKey.NO_KEY;
     } else {
       return CacheKey.from(id);
     }
   }
};

//Build the ApolloClient
ApolloClient apolloClient = ApolloClient.builder()
  .serverUrl("/")
  .normalizedCache(cacheFactory, resolver)
  .okHttpClient(okHttpClient)
  .build();
```

</MultiCodeBlock>

## Normalized In-Memory Cache:

To enable Normalized In-Memory Cache support, add the dependency to your project's build.gradle file. The latest version is
[![Download](https://api.bintray.com/packages/apollographql/android/apollo/images/download.svg)](https://bintray.com/apollographql/android/apollo-normalized-cache/_latestVersion)

```kotlin:title=build.gradle
dependencies {
  implementation("com.apollographql.apollo:apollo-normalized-cache:x.y.z")
}
``` 

### Usage

<MultiCodeBlock>

```kotlin:title=Kotlin
// Create NormalizedCacheFactory
val cacheFactory = LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024).build())

// Build the ApolloClient
val apolloClient = ApolloClient.builder()
  .serverUrl("/")
  .normalizedCache(cacheFactory, resolver)
  .okHttpClient(okHttpClient)
  .build())
```

```java:title=Java
// Create NormalizedCacheFactory
NormalizedCacheFactory cacheFactory = new LruNormalizedCacheFactory(EvictionPolicy.builder().maxSizeBytes(10 * 1024).build());

// Build the ApolloClient
ApolloClient apolloClient = ApolloClient.builder()
  .serverUrl("/")
  .normalizedCache(cacheFactory, resolver)
  .okHttpClient(okHttpClient)
  .build();
```

</MultiCodeBlock>

## Chaining Caches:

You can use both a memory cache and disk cache, with a cache chain. Reads will read from the first cache hit in the chain. Writes will
propagate down the entire chain.

<MultiCodeBlock>

```kotlin:title=Kotlin

val sqlCacheFactory = SqlNormalizedCacheFactory(context, "db_name")
val memoryFirstThenSqlCacheFactory = LruNormalizedCacheFactory(
    EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()
).chain(sqlCacheFactory)

```

```java:title=Java

NormalizedCacheFactory sqlCacheFactory = new SqlNormalizedCacheFactory(context, "db_name");
NormalizedCacheFactory memoryFirstThenSqlCacheFactory = new LruNormalizedCacheFactory(
  EvictionPolicy.builder().maxSizeBytes(10 * 1024).build()
).chain(sqlCacheFactory);

```
</MultiCodeBlock>

## Examples

[Java Sample](https://github.com/apollographql/apollo-android/tree/master/samples/java-sample) has an example of chained cache of in-memory
and SQLite caches.

[Kotlin Sample](https://github.com/apollographql/apollo-android/tree/master/samples/kotlin-sample) has an example of SQLite cache usage
written in Kotlin.
 
For other concrete examples of using response caches, please see the following tests in their respective modules:
`SqlNormalizedCacheTest`, `LruNormalizedCacheTest`. 
